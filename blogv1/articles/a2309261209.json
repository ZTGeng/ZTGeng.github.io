{
  "title": "学习笔记：平方根倒数与0x5f3759df",
  "date": "2023-09-26 12:09:49",
  "filename": "a2309261209",
  "text": [
    {
      "data": "我发现自己好不容易搞清楚的东西很快就会忘记，除非写个笔记下来，忘记了也许看看还能想起来。"
    },
    {
      "data": "本文是关于雷神之锤游戏代码中使用过的平方根倒数速算法（[[https://zh.wikipedia.org/zh-hans/平方根倒数速算法|维基百科]]）的原理。尽管维基百科一个流传很广的 youtube 视频已经解释得很清楚，我还是记录下来我当下的理解。"
    },
    {
      "type": "head",
      "data": "代码："
    },
    {
      "type": "code",
      "data": "float Q_rsqrt( float number )\n{\n        long i;\n        float x2, y;\n        const float threehalfs = 1.5F;\n\n        x2 = number * 0.5F;\n        y = number;\n        i = * ( long * ) &amp;y;                       // evil floating point bit level hacking\n        i = 0x5f3759df - ( i &gt;&gt; 1 );               // what the fuck?\n        y = * ( float * ) &amp;i;\n        y = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration\n//      y = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed\n\n        return y;\n}"
    },
    {
      "data": "这段代码可以快速求出输入值的平方根倒数（``1/sqrt(x)``）的近似值。"
    },
    {
      "type": "head",
      "data": "原理："
    },
    {
      "data": "这个算法使用了两个核心技巧。一是将浮点数按照整数的规则进行运算；二是利用函数 ``y = log_2(1+x)`` 在 0 到 1 区间内与函数 ``y = x`` 非常吻合的特性。"
    },
    {
      "data": "**1，对浮点数进行整形运算**"
    },
    {
      "type": "image",
      "data": "p2309261031.png"
    },
    {
      "data": "浮点数的表示方法本质上是二进制下的科学计数法。如上图 32 位 bit，最开始 1 bit 是正负号（在本算法中，因为是计算平方根，所以输入值永远为正）；之后 8 bits 为指数部分（2 为底数）；最后 23 bits 为有效数字的小数部分（这个二进制的有效数字可以写成形如 1.0100... 的形式，其中整数部分永远为 1，省略）。"
    },
    {
      "data": "然后，我们假设指数部分的值为 E；有效数字小数部分单独取出来、以整数的形式表示的值为 M。再尝试用 E 和 M 构建这个浮点数的值。"
    },
    {
      "data": "注意，M 是一个整数，如果要将它变回形如 0.0100... 的小数，需要除以 2^23。同时，E 是取值为 [0, 255] 的非负整数，需要减去 127 调整为取值 [-127, 128] 的整数。因此，原浮点数可以表示为："
    },
    {
      "data": "``(1 + M / 2^23) * 2^(E - 127)``"
    },
    {
      "data": "但是，速算法将此浮点数强制按照整数的格式进行加减和移位运算，此时它所代表的整数数值则与浮点数数值完全不同："
    },
    {
      "data": "``(E * 2^23 + M)``"
    },
    {
      "data": "本来，浮点数应该按照特殊的规则、对齐位数后进行加减运算，同时浮点数的“移位”运算毫无意义。对输入的浮点数进行“移位”后，与一个常数进行整数减法运算，所得的值有何意义呢？这就需要进行以下推导："
    },
    {
      "data": "**2，获取近似值的数学推导**"
    },
    {
      "data": "回到最初，假设输入值是 x，平方根倒数计算结果是 y，即："
    },
    {
      "type": "code",
      "data": "y = 1 / sqrt(x)"
    },
    {
      "data": "可以写成指数的形式："
    },
    {
      "type": "code",
      "data": "y = x^(-1/2)"
    },
    {
      "data": "两边求 log："
    },
    {
      "type": "code",
      "data": "log_2(y) = log_2[x^(-1/2)]\nlog_2(y) = -1/2 * log_2(x)"
    },
    {
      "data": "由于 x 和 y 都是浮点数，设他们的 E 和 M 分别是 Ex、Mx、Ey、My。将上式写成浮点数表示方法："
    },
    {
      "type": "code",
      "data": "log_2[(1 + My / 2^23) * 2^(Ey - 127)] = -1/2 * log_2[(1 + Mx / 2^23) * 2^(Ex - 127)]"
    },
    {
      "data": "根据 log 运算规则可进行如下变形："
    },
    {
      "type": "code",
      "data": "log_2(1 + My / 2^23) + log_2[2^(Ey - 127)] = -1/2 * {log_2(1 + Mx / 2^23) + log_2[2^(Ex - 127)]}\nlog_2(1 + My / 2^23) + Ey - 127 = -1/2 * [log_2(1 + Mx / 2^23) + Ex - 127]"
    },
    {
      "data": "移项、合并同类项："
    },
    {
      "type": "code",
      "data": "log_2(1 + My / 2^23) + Ey - 127 = -1/2 * log_2(1 + Mx / 2^23) - 1/2 * Ex + 1/2 * 127\nlog_2(1 + My / 2^23) + Ey = -1/2 * log_2(1 + Mx / 2^23) - 1/2 * Ex + 3/2 * 127"
    },
    {
      "data": "注意左右两边都有 ``log_2(1 + M / 2^23)`` 这样形式的项。而 M / 2^23 是有效数字的小数部分，也就是说它的取值范围是 [0, 1)。而我们看下图："
    },
    {
      "type": "image",
      "data": "p2309261123.png"
    },
    {
      "data": "图中红色曲线为函数 ``y = log_2(1+x)`` ，它在 0 到 1 区间内与进行了稍许移位的函数 ``y = x`` （蓝色直线）非常吻合。也就是说，我们可以用 ``x + σ``（σ 为一个很小的常数，其值待定）来近似地替换 ``log_2(1+x)`` 的值。进行替换后，上式变为："
    },
    {
      "type": "code",
      "data": "My / 2^23 + σ + Ey = -1/2 * (Mx / 2^23 + σ) - 1/2 * Ex + 3/2 * 127"
    },
    {
      "data": "移项、合并同类项、各项乘以 2^23："
    },
    {
      "type": "code",
      "data": "My / 2^23 + σ + Ey = -1/2 * (Mx / 2^23) - 1/2 * σ - 1/2 * Ex + 3/2 * 127\nMy / 2^23 + Ey = -1/2 * (Mx / 2^23) - 1/2 * Ex + 3/2 * 127 - 3/2 * σ\nMy / 2^23 + Ey = -1/2 * (Mx / 2^23 + Ex) + 3/2 * (127 - σ)\nMy + Ey * 2^23 = -1/2 * (Mx + Ex * 2^23) + 3/2 * (127 - σ) * 2^23"
    },
    {
      "data": "注意，原先作为浮点数组成部分的 E 和 M，此时此刻恰好符合整数的表达形式 ``(E * 2^23 + M)``。也就是说，当我们将一个浮点数（设为float_x、float_y）强制看成一个整数（记作 int_x、int_y）去进行运算，则根据 ``float_y = 1 / sqrt(float_x)`` 可以推导出："
    },
    {
      "type": "code",
      "data": "int_y = -1/2 * int_x + 3/2 * (127 - σ) * 2^23"
    },
    {
      "data": "这正是算法中 ``i = 0x5f3759df - ( i &gt;&gt; 1 );`` 所进行的运算。其中常数 0x5f3759df 即为 3/2 * (127 - σ) * 2^23 的取值；右移一位即除以 2。这个整数运算所得的结果再强制变换回浮点数形式，就得到了 float_y 的近似值。"
    },
    {
      "data": "**3，后续步骤**"
    },
    {
      "data": "最后对近似值使用牛顿迭代法，进一步使其精确。牛顿迭代法是利用函数导数的性质、通过多次迭代近似地求解方程的方法。详见[[https://zh.wikipedia.org/zh-hans/牛顿法|维基百科]]。"
    }
  ]
}